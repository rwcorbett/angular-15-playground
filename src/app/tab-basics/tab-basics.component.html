<div class="container-wrapper tab-basics">

  <input type="hidden" #selectionBasic>

  <h2 class="card highlight-card">ng Basics</h2>

  <div class="card-container">
    <button class="card card-small" (click)="selectionBasic.value = 'Components'" tabindex="0">
      <app-card-label cardName="Components"></app-card-label>
    </button>
    <button class="card card-small" (click)="selectionBasic.value = 'Templates'" tabindex="0">
      <app-card-label cardName="Templates & Data"></app-card-label>
    </button>
    <button class="card card-small" (click)="selectionBasic.value = 'Modules'" tabindex="0">
      <app-card-label cardName="Modules"></app-card-label>
    </button>
    <button class="card card-small" (click)="selectionBasic.value = 'DependencyInjection'" tabindex="0">
      <app-card-label cardName="Dependency Injection"></app-card-label>
    </button>
    <button class="card card-small" (click)="selectionBasic.value = 'Services'" tabindex="0">
      <app-card-label cardName="Services"></app-card-label>
    </button>
    <button class="card card-small" (click)="selectionBasic.value = 'Routing'" tabindex="0">
      <app-card-label cardName="Routing"></app-card-label>
    </button>
  </div>
  <div class="terminal" [ngSwitch]="selectionBasic.value">
    <pre *ngSwitchDefault>... click to view</pre>

    <pre *ngSwitchCase="'Components'">Components
- create new component via CLI
- (@)Component() decorator identifies the class immediately below it
- ensure that main app is aware of component
- styles and template can be inline or separate files
- add @Input and @Output for data communication with component as needed
- Use [] to bind from source to view
- Use () to bind from view to source
- Use [()] to bind in a two-way sequence of view to source to view
    </pre>

    <pre *ngSwitchCase="'Templates'">Templates
- combines HTML with Angular markup
- data binding: Event binding (input or data) or Property binding (computed values)
- two-way data binding; changes in the DOM, such as user choices, are also reflected in your program data
    </pre>

    <pre *ngSwitchCase="'Modules'">Modules</pre>

    <pre *ngSwitchCase="'DependencyInjection'">DependencyInjection
- bring services and access to resources into components
- use (@)Injectable() decorator, application-wide root injector
    </pre>

    <pre *ngSwitchCase="'Services'">Services
- share logic across components, narrow, well-defined purpose
- use services for things that do not involve view or app logic (fetch data, validate, logging)
- service class definition use (@)Injectable() decorator - for DI - to pass metadata
- services at 'root' create singleton instance and injects that into components -> (@)Injectable passed
- services passed at component will create new instances of service with each new component that uses it -> (@)Component declared
- Angular will do tree-shaking to remove unused services
    </pre>

    <pre *ngSwitchCase="'Routing'">Routing</pre>
  </div>
</div>
